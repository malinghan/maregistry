# v6.0 — 数据持久化

## 代码结构

```
src/main/java/com/malinghan/maregistry/
├── MaregistryApplication.java          # Spring Boot 入口（无变化）
├── MaRegistryController.java           # REST控制器（无变化）
├── MaRegistryConfig.java               # 配置类，新增 FileRegistryStore Bean 注册
├── MaExceptionHandler.java             # 全局异常处理器（无变化）
├── ExceptionResponse.java              # 异常响应封装类（无变化）
├── model/
│   └── InstanceMeta.java               # 服务实例数据模型（无变化）
├── service/
│   ├── RegistryService.java            # 注册服务接口（无变化）
│   └── MaRegistryService.java          # 内存实现，新增持久化生命周期管理
├── store/
│   ├── RegistryStore.java              # 新增：存储后端抽象接口
│   └── FileRegistryStore.java          # 新增：JSON文件存储实现
├── health/
│   ├── HealthChecker.java              # 健康检查接口（无变化）
│   └── MaHealthChecker.java            # 健康检查实现（无变化）
├── cluster/
│   ├── Server.java                     # 集群节点模型（无变化）
│   ├── Cluster.java                    # 集群管理器（无变化）
│   ├── Election.java                   # 选举算法实现（无变化）
│   ├── ServerHealth.java               # 集群健康检查（无变化）
│   ├── MaRegistryConfigProperties.java # 配置属性类，新增持久化配置项
│   └── Snapshot.java                   # 数据快照模型（无变化）
└── http/
    ├── HttpInvoker.java                # HTTP调用接口（无变化）
    ├── HttpInvokeException.java        # HTTP调用异常类（无变化）
    └── OkHttpInvoker.java              # OkHttp实现（无变化）
```

## 核心功能实现

### 1. 存储抽象接口 (RegistryStore.java)

```java
public interface RegistryStore {
    void save(Snapshot snapshot);
    Snapshot load();
}
```

- `save` — 将快照持久化到存储后端
- `load` — 从存储后端加载快照，无数据时返回 `null`
- 接口设计为未来支持数据库等其他后端预留扩展点

### 2. 文件存储实现 (FileRegistryStore.java)

#### 核心逻辑

```java
@Override
public void save(Snapshot snapshot) {
    Path tmp = Paths.get(snapshotPath + ".tmp");
    objectMapper.writeValue(tmp.toFile(), snapshot);
    Files.move(tmp, target, REPLACE_EXISTING, ATOMIC_MOVE);
}

@Override
public Snapshot load() {
    File file = new File(snapshotPath);
    if (!file.exists()) return null;
    return objectMapper.readValue(file, Snapshot.class);
}
```

#### 设计要点
- **原子写入**：先写临时文件再 rename，避免写入中途崩溃导致文件损坏
- **目录自动创建**：`Files.createDirectories` 确保父目录存在
- **容错处理**：文件不存在返回 `null`，IO 异常记录日志不抛出
- **JSON 序列化**：复用 Spring Boot 自动配置的 `ObjectMapper`

### 3. 新增配置项 (MaRegistryConfigProperties.java)

```java
// 是否启用持久化，默认 true
private boolean persistenceEnabled = true;

// 快照文件存储路径，默认 ./data/registry-snapshot.json
private String snapshotPath = "./data/registry-snapshot.json";

// 定时落盘间隔（秒），默认 30 秒
private int snapshotInterval = 30;
```

对应 `application.yml`：

```yaml
maregistry:
  persistence-enabled: true
  snapshot-path: ./data/registry-snapshot.json
  snapshot-interval: 30
```

### 4. 持久化生命周期管理 (MaRegistryService.java)

#### 架构图

```
MaRegistryService
  ├── @PostConstruct init()
  │     └── store.load() → restore(snapshot)
  ├── ScheduledExecutorService
  │     └── 每 snapshotInterval 秒 → store.save(snapshot())
  └── @PreDestroy destroy()
        └── store.save(snapshot()) + scheduler.shutdown()
```

#### 启动加载

```java
@PostConstruct
public void init() {
    if (store != null) {
        Snapshot snapshot = store.load();
        if (snapshot != null) {
            restore(snapshot);
        }
        int interval = properties.getSnapshotInterval();
        scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(
            () -> store.save(snapshot()), interval, interval, TimeUnit.SECONDS);
    }
}
```

#### 关闭落盘

```java
@PreDestroy
public void destroy() {
    if (store != null) store.save(snapshot());
    if (scheduler != null) scheduler.shutdown();
}
```

#### 关键设计
- `RegistryStore` 使用 `@Autowired(required = false)` 注入，`persistenceEnabled=false` 时 Bean 不存在也不报错
- 复用已有的 `snapshot()` 和 `restore(Snapshot)` 方法，不改变其逻辑
- `@PreDestroy` 保证正常关闭时最后一次落盘不丢数据

### 5. 条件 Bean 注册 (MaRegistryConfig.java)

```java
@Bean
@ConditionalOnProperty(
    prefix = "maregistry",
    name = "persistence-enabled",
    havingValue = "true",
    matchIfMissing = true
)
public RegistryStore registryStore(ObjectMapper objectMapper,
                                   MaRegistryConfigProperties properties) {
    return new FileRegistryStore(objectMapper, properties);
}
```

`matchIfMissing = true` 表示未配置该项时默认启用持久化。

## 数据流

### 启动恢复流程

```
应用启动
  └── @PostConstruct init()
        ├── FileRegistryStore.load()
        │     ├── 文件存在 → 反序列化 JSON → Snapshot
        │     └── 文件不存在 → null
        └── snapshot != null → restore(snapshot)
              ├── 清空 REGISTRY / VERSIONS / TIMESTAMPS
              └── 从快照填充内存数据
```

### 定时落盘流程

```
每 30 秒
  └── snapshot()          → 生成内存快照副本
        └── store.save()  → 写 .tmp 文件 → atomic rename → .json 文件
```

### 关闭落盘流程

```
JVM 关闭信号
  └── @PreDestroy destroy()
        ├── snapshot() → store.save()   # 最后一次落盘
        └── scheduler.shutdown()
```

## 测试流程

### 1. 验证快照文件生成

```bash
# 启动服务
mvn spring-boot:run

# 注册服务实例
curl -X POST "http://localhost:8081/reg?service=com.test.HelloService" \
  -H "Content-Type: application/json" \
  -d '{"scheme":"http","host":"192.168.1.100","port":8080,"context":"hello"}'

# 等待 30 秒，或直接停止服务触发 @PreDestroy 落盘
# 查看快照文件
cat ./data/registry-snapshot.json | jq '.'
```

预期输出：

```json
{
  "REGISTRY": {
    "com.test.HelloService": [
      {"scheme": "http", "host": "192.168.1.100", "port": 8080, "context": "hello"}
    ]
  },
  "VERSIONS": {"com.test.HelloService": 0},
  "TIMESTAMPS": {},
  "version": 1
}
```

### 2. 验证重启数据恢复

```bash
# 停止服务（触发 @PreDestroy 落盘）
# 重新启动服务
mvn spring-boot:run

# 查询服务，确认数据已恢复
curl "http://localhost:8081/findAll?service=com.test.HelloService"

# 查看快照版本号与重启前一致
curl "http://localhost:8081/snapshot" | jq '.version'
```

### 3. 禁用持久化

```yaml
maregistry:
  persistence-enabled: false
```

禁用后 `FileRegistryStore` Bean 不会注册，服务退化为纯内存模式，行为与 v5.0 完全一致。

## 后续优化方向

1. **增量持久化**：仅记录变更操作（WAL），减少每次全量序列化开销
2. **数据库后端**：实现 `JdbcRegistryStore`，支持 MySQL/PostgreSQL 持久化
3. **快照压缩**：对 JSON 文件进行 gzip 压缩，减少磁盘占用
4. **多副本备份**：保留最近 N 个快照文件，防止单文件损坏导致数据丢失
